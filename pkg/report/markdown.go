package report

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"digital.vasic.challenges/pkg/challenge"
)

// MarkdownReporter generates Markdown reports from challenge
// results.
type MarkdownReporter struct {
	outputDir string
}

// NewMarkdownReporter creates a new Markdown reporter.
func NewMarkdownReporter(outputDir string) *MarkdownReporter {
	return &MarkdownReporter{outputDir: outputDir}
}

// GenerateReport creates a Markdown report for a single
// challenge result. The returned error is always nil since
// Markdown generation to a bytes.Buffer cannot fail.
func (r *MarkdownReporter) GenerateReport(
	result *challenge.Result,
) ([]byte, error) {
	var buf bytes.Buffer
	r.WriteReport(&buf, result)
	return buf.Bytes(), nil
}

// WriteReport writes a Markdown report to the specified writer.
func (r *MarkdownReporter) WriteReport(
	w io.Writer,
	result *challenge.Result,
) error {
	fmt.Fprintf(
		w, "# Challenge Report: %s\n\n", result.ChallengeName,
	)
	fmt.Fprintf(
		w, "**Challenge ID:** %s\n\n", result.ChallengeID,
	)
	fmt.Fprintf(
		w, "**Generated:** %s\n\n",
		result.EndTime.Format(time.RFC3339),
	)

	// Summary table
	fmt.Fprintln(w, "## Summary")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Metric | Value |")
	fmt.Fprintln(w, "|--------|-------|")
	fmt.Fprintf(
		w, "| Status | **%s** |\n",
		strings.ToUpper(result.Status),
	)
	fmt.Fprintf(
		w, "| Start Time | %s |\n",
		result.StartTime.Format(time.RFC3339),
	)
	fmt.Fprintf(
		w, "| End Time | %s |\n",
		result.EndTime.Format(time.RFC3339),
	)
	fmt.Fprintf(w, "| Duration | %v |\n", result.Duration)

	if result.Error != "" {
		fmt.Fprintf(w, "| Error | %s |\n", result.Error)
	}

	r.writeMetrics(w, result)
	r.writeAssertions(w, result)
	r.writeOutputs(w, result)
	r.writeLogs(w, result)

	fmt.Fprintln(w)
	fmt.Fprintln(w, "---")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "*Generated by Challenges Framework*")

	return nil
}

func (r *MarkdownReporter) writeMetrics(
	w io.Writer,
	result *challenge.Result,
) {
	if len(result.Metrics) == 0 {
		return
	}

	fmt.Fprintln(w)
	fmt.Fprintln(w, "## Metrics")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Metric | Value | Unit |")
	fmt.Fprintln(w, "|--------|-------|------|")

	var names []string
	for name := range result.Metrics {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		m := result.Metrics[name]
		unit := m.Unit
		if unit == "" {
			unit = "-"
		}
		fmt.Fprintf(
			w, "| %s | %.2f | %s |\n", m.Name, m.Value, unit,
		)
	}
}

func (r *MarkdownReporter) writeAssertions(
	w io.Writer,
	result *challenge.Result,
) {
	if len(result.Assertions) == 0 {
		return
	}

	fmt.Fprintln(w)
	fmt.Fprintln(w, "## Assertions")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Type | Target | Passed | Message |")
	fmt.Fprintln(w, "|------|--------|--------|---------|")

	passedCount := 0
	for _, a := range result.Assertions {
		passed := "No"
		if a.Passed {
			passed = "Yes"
			passedCount++
		}
		fmt.Fprintf(
			w, "| %s | %s | %s | %s |\n",
			a.Type, a.Target, passed, a.Message,
		)
	}

	total := len(result.Assertions)
	pct := float64(passedCount) / float64(total) * 100
	fmt.Fprintf(
		w, "\n**Pass Rate:** %d/%d (%.0f%%)\n",
		passedCount, total, pct,
	)
}

func (r *MarkdownReporter) writeOutputs(
	w io.Writer,
	result *challenge.Result,
) {
	if len(result.Outputs) == 0 {
		return
	}

	fmt.Fprintln(w)
	fmt.Fprintln(w, "## Output Files")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Name | Path |")
	fmt.Fprintln(w, "|------|------|")

	for name, path := range result.Outputs {
		fmt.Fprintf(w, "| %s | `%s` |\n", name, path)
	}
}

func (r *MarkdownReporter) writeLogs(
	w io.Writer,
	result *challenge.Result,
) {
	fmt.Fprintln(w)
	fmt.Fprintln(w, "## Log Files")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Log Type | Path |")
	fmt.Fprintln(w, "|----------|------|")
	fmt.Fprintf(
		w, "| Challenge Log | `%s` |\n",
		result.Logs.ChallengeLog,
	)
	fmt.Fprintf(
		w, "| Output Log | `%s` |\n",
		result.Logs.OutputLog,
	)
	if result.Logs.APIRequests != "" {
		fmt.Fprintf(
			w, "| API Requests | `%s` |\n",
			result.Logs.APIRequests,
		)
	}
	if result.Logs.APIResponses != "" {
		fmt.Fprintf(
			w, "| API Responses | `%s` |\n",
			result.Logs.APIResponses,
		)
	}
}

// GenerateMasterSummary creates a Markdown summary of all
// challenge results.
func (r *MarkdownReporter) GenerateMasterSummary(
	results []*challenge.Result,
) ([]byte, error) {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, "# Challenges Framework - Master Summary")
	fmt.Fprintln(&buf)
	fmt.Fprintf(
		&buf, "**Generated:** %s\n\n",
		time.Now().Format(time.RFC3339),
	)

	fmt.Fprintln(&buf, "## Overview")
	fmt.Fprintln(&buf)
	fmt.Fprintln(
		&buf,
		"| Challenge | Status | Duration | Last Run |",
	)
	fmt.Fprintln(
		&buf,
		"|-----------|--------|----------|----------|",
	)

	passedCount := 0
	totalDuration := time.Duration(0)

	for _, result := range results {
		status := strings.ToUpper(result.Status)
		if result.Status == challenge.StatusPassed {
			passedCount++
		}
		totalDuration += result.Duration
		fmt.Fprintf(
			&buf, "| %s | %s | %v | %s |\n",
			result.ChallengeName,
			status,
			result.Duration,
			result.EndTime.Format("2006-01-02 15:04:05"),
		)
	}

	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "## Statistics")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "| Metric | Value |")
	fmt.Fprintln(&buf, "|--------|-------|")
	fmt.Fprintf(
		&buf, "| Total Challenges | %d |\n", len(results),
	)
	fmt.Fprintf(&buf, "| Passed | %d |\n", passedCount)
	fmt.Fprintf(
		&buf, "| Failed | %d |\n", len(results)-passedCount,
	)

	if len(results) > 0 {
		pct := float64(passedCount) /
			float64(len(results)) * 100
		fmt.Fprintf(&buf, "| Pass Rate | %.0f%% |\n", pct)
	}
	fmt.Fprintf(
		&buf, "| Total Duration | %v |\n", totalDuration,
	)

	r.writeChallengeDetails(&buf, results)

	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "---")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "*Generated by Challenges Framework*")

	return buf.Bytes(), nil
}

func (r *MarkdownReporter) writeChallengeDetails(
	buf *bytes.Buffer,
	results []*challenge.Result,
) {
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, "## Challenge Details")
	fmt.Fprintln(buf)

	for _, result := range results {
		fmt.Fprintf(buf, "### %s\n\n", result.ChallengeName)
		fmt.Fprintf(
			buf, "- **Status:** %s\n",
			strings.ToUpper(result.Status),
		)
		fmt.Fprintf(
			buf, "- **Duration:** %v\n", result.Duration,
		)

		if len(result.Metrics) > 0 {
			fmt.Fprintln(buf, "- **Key Metrics:**")
			for _, m := range result.Metrics {
				fmt.Fprintf(
					buf, "  - %s: %.2f %s\n",
					m.Name, m.Value, m.Unit,
				)
			}
		}

		if len(result.Assertions) > 0 {
			passed := 0
			for _, a := range result.Assertions {
				if a.Passed {
					passed++
				}
			}
			fmt.Fprintf(
				buf, "- **Assertions:** %d/%d passed\n",
				passed, len(result.Assertions),
			)
		}

		if result.Error != "" {
			fmt.Fprintf(
				buf, "- **Error:** %s\n", result.Error,
			)
		}

		fmt.Fprintln(buf)
	}
}

// SaveReport saves a Markdown report to a file.
func (r *MarkdownReporter) SaveReport(
	result *challenge.Result,
	filename string,
) error {
	data, _ := r.GenerateReport(result)
	path := filepath.Join(r.outputDir, filename)
	return os.WriteFile(path, data, 0644)
}

// SaveMasterSummary saves a master summary to a file.
func (r *MarkdownReporter) SaveMasterSummary(
	results []*challenge.Result,
	filename string,
) error {
	data, _ := r.GenerateMasterSummary(results)
	path := filepath.Join(r.outputDir, filename)
	return os.WriteFile(path, data, 0644)
}
